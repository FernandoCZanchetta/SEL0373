{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, Component, Input, Output, HostBinding, NgModule } from '@angular/core';\nimport { LinkedList, isBs3, getBsVer } from 'ngx-bootstrap/utils';\nimport * as i2 from '@angular/common';\nimport { CommonModule } from '@angular/common';\n/**\n * Returns the index of the last element in the array where predicate is true, and -1\n * otherwise.\n * @param array The source array to search in\n * @param predicate find calls predicate once for each element of the array, in descending\n * order, until it finds one where predicate returns true. If such an element is found,\n * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n */\n\nfunction CarouselComponent_ng_container_1_li_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"li\", 7);\n    i0.ɵɵlistener(\"click\", function CarouselComponent_ng_container_1_li_2_Template_li_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r8);\n      const i_r6 = restoredCtx.index;\n      const ctx_r7 = i0.ɵɵnextContext(2);\n      return ctx_r7.selectSlide(i_r6);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const slide_r5 = ctx.$implicit;\n    i0.ɵɵclassProp(\"active\", slide_r5.active === true);\n  }\n}\n\nfunction CarouselComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"ol\", 5);\n    i0.ɵɵtemplate(2, CarouselComponent_ng_container_1_li_2_Template, 1, 2, \"li\", 6);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.indicatorsSlides());\n  }\n}\n\nfunction CarouselComponent_ng_container_2_button_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r13 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 9);\n    i0.ɵɵlistener(\"click\", function CarouselComponent_ng_container_2_button_2_Template_button_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r13);\n      const i_r11 = restoredCtx.index;\n      const ctx_r12 = i0.ɵɵnextContext(2);\n      return ctx_r12.selectSlide(i_r11);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const slide_r10 = ctx.$implicit;\n    const i_r11 = ctx.index;\n    const ctx_r9 = i0.ɵɵnextContext(2);\n    i0.ɵɵclassProp(\"active\", slide_r10.active === true);\n    i0.ɵɵattribute(\"data-bs-target\", \"#\" + ctx_r9.currentId)(\"data-bs-slide-to\", i_r11);\n  }\n}\n\nfunction CarouselComponent_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 5);\n    i0.ɵɵtemplate(2, CarouselComponent_ng_container_2_button_2_Template, 1, 4, \"button\", 8);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r1.indicatorsSlides());\n  }\n}\n\nfunction CarouselComponent_a_5_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 13);\n    i0.ɵɵtext(1, \"Previous\");\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction CarouselComponent_a_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r16 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"a\", 10);\n    i0.ɵɵlistener(\"click\", function CarouselComponent_a_5_Template_a_click_0_listener() {\n      i0.ɵɵrestoreView(_r16);\n      const ctx_r15 = i0.ɵɵnextContext();\n      return ctx_r15.previousSlide();\n    });\n    i0.ɵɵelement(1, \"span\", 11);\n    i0.ɵɵtemplate(2, CarouselComponent_a_5_span_2_Template, 2, 0, \"span\", 12);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"disabled\", ctx_r2.checkDisabledClass(\"prev\"));\n    i0.ɵɵattribute(\"data-bs-target\", \"#\" + ctx_r2.currentId);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.isBs4);\n  }\n}\n\nfunction CarouselComponent_a_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r18 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"a\", 14);\n    i0.ɵɵlistener(\"click\", function CarouselComponent_a_6_Template_a_click_0_listener() {\n      i0.ɵɵrestoreView(_r18);\n      const ctx_r17 = i0.ɵɵnextContext();\n      return ctx_r17.nextSlide();\n    });\n    i0.ɵɵelement(1, \"span\", 15);\n    i0.ɵɵelementStart(2, \"span\", 13);\n    i0.ɵɵtext(3, \"Next\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"disabled\", ctx_r3.checkDisabledClass(\"next\"));\n    i0.ɵɵattribute(\"data-bs-target\", \"#\" + ctx_r3.currentId);\n  }\n}\n\nconst _c0 = function (a0) {\n  return {\n    \"display\": a0\n  };\n};\n\nconst _c1 = [\"*\"];\n\nfunction findLastIndex(array, predicate) {\n  let l = array.length;\n\n  while (l--) {\n    if (predicate(array[l], l, array)) {\n      return l;\n    }\n  }\n\n  return -1;\n}\n\nfunction chunkByNumber(array, size) {\n  const out = [];\n  const n = Math.ceil(array.length / size);\n  let i = 0;\n\n  while (i < n) {\n    const chunk = array.splice(0, i === n - 1 && size < array.length ? array.length : size);\n    out.push(chunk);\n    i++;\n  }\n\n  return out;\n}\n\nfunction isNumber(value) {\n  return typeof value === 'number' || Object.prototype.toString.call(value) === '[object Number]';\n}\n\nclass CarouselConfig {\n  constructor() {\n    /* Default interval of auto changing of slides */\n    this.interval = 5000;\n    /* Is loop of auto changing of slides can be paused */\n\n    this.noPause = false;\n    /* Is slides can wrap from the last to the first slide */\n\n    this.noWrap = false;\n    /* Show carousel-indicators */\n\n    this.showIndicators = true;\n    /* Slides can be paused on focus */\n\n    this.pauseOnFocus = false;\n    /* If `true` - carousel indicators indicate slides chunks works ONLY if singleSlideOffset = FALSE */\n\n    this.indicatorsByChunk = false;\n    /* If value more then 1 — carousel works in multilist mode */\n\n    this.itemsPerSlide = 1;\n    /* If `true` — carousel shifts by one element. By default carousel shifts by number\n      of visible elements (itemsPerSlide field) */\n\n    this.singleSlideOffset = false;\n  }\n\n}\n\nCarouselConfig.ɵfac = function CarouselConfig_Factory(t) {\n  return new (t || CarouselConfig)();\n};\n\nCarouselConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CarouselConfig,\n  factory: CarouselConfig.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CarouselConfig, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n/***\n * pause (not yet supported) (?string='hover') - event group name which pauses\n * the cycling of the carousel, if hover pauses on mouseenter and resumes on\n * mouseleave keyboard (not yet supported) (?boolean=true) - if false\n * carousel will not react to keyboard events\n * note: swiping not yet supported\n */\n\n\nvar Direction;\n\n(function (Direction) {\n  Direction[Direction[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  Direction[Direction[\"NEXT\"] = 1] = \"NEXT\";\n  Direction[Direction[\"PREV\"] = 2] = \"PREV\";\n})(Direction || (Direction = {}));\n\nlet _currentId = 1;\n/**\n * Base element to create carousel\n */\n\nclass CarouselComponent {\n  constructor(config, ngZone) {\n    this.ngZone = ngZone;\n    /* If `true` — carousel will not cycle continuously and will have hard stops (prevent looping) */\n\n    this.noWrap = false;\n    /*  If `true` — will disable pausing on carousel mouse hover */\n\n    this.noPause = false;\n    /*  If `true` — carousel-indicators are visible  */\n\n    this.showIndicators = true;\n    /*  If `true` - autoplay will be stopped on focus */\n\n    this.pauseOnFocus = false;\n    /* If `true` - carousel indicators indicate slides chunks\n       works ONLY if singleSlideOffset = FALSE */\n\n    this.indicatorsByChunk = false;\n    /* If value more then 1 — carousel works in multilist mode */\n\n    this.itemsPerSlide = 1;\n    /* If `true` — carousel shifts by one element. By default carousel shifts by number\n       of visible elements (itemsPerSlide field) */\n\n    this.singleSlideOffset = false;\n    /** Turn on/off animation. Animation doesn't work for multilist carousel */\n\n    this.isAnimated = false;\n    /** Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property */\n\n    this.activeSlideChange = new EventEmitter(false);\n    /** Will be emitted when active slides has been changed in multilist mode */\n\n    this.slideRangeChange = new EventEmitter();\n    /* Index to start display slides from it */\n\n    this.startFromIndex = 0;\n    this._interval = 5000;\n    this._slides = new LinkedList();\n    this._currentVisibleSlidesIndex = 0;\n    this.isPlaying = false;\n    this.destroyed = false;\n    this.currentId = 0;\n\n    this.getActive = slide => slide.active;\n\n    this.makeSlidesConsistent = slides => {\n      slides.forEach((slide, index) => slide.item.order = index);\n    };\n\n    Object.assign(this, config);\n    this.currentId = _currentId++;\n  }\n  /** Index of currently displayed slide(started for 0) */\n\n\n  set activeSlide(index) {\n    if (this.multilist) {\n      return;\n    }\n\n    if (isNumber(index)) {\n      this.customActiveSlide = index;\n    }\n\n    if (this._slides.length && index !== this._currentActiveSlide) {\n      this._select(index);\n    }\n  }\n\n  get activeSlide() {\n    return this._currentActiveSlide || 0;\n  }\n  /**\n   * Delay of item cycling in milliseconds. If false, carousel won't cycle\n   * automatically.\n   */\n\n\n  get interval() {\n    return this._interval;\n  }\n\n  set interval(value) {\n    this._interval = value;\n    this.restartTimer();\n  }\n\n  get slides() {\n    return this._slides.toArray();\n  }\n\n  get isFirstSlideVisible() {\n    const indexes = this.getVisibleIndexes();\n\n    if (!indexes || indexes instanceof Array && !indexes.length) {\n      return false;\n    }\n\n    return indexes.includes(0);\n  }\n\n  get isLastSlideVisible() {\n    const indexes = this.getVisibleIndexes();\n\n    if (!indexes || indexes instanceof Array && !indexes.length) {\n      return false;\n    }\n\n    return indexes.includes(this._slides.length - 1);\n  }\n\n  get isBs4() {\n    return !isBs3();\n  }\n\n  get _bsVer() {\n    return getBsVer();\n  }\n\n  ngAfterViewInit() {\n    setTimeout(() => {\n      if (this.singleSlideOffset) {\n        this.indicatorsByChunk = false;\n      }\n\n      if (this.multilist) {\n        this._chunkedSlides = chunkByNumber(this.mapSlidesAndIndexes(), this.itemsPerSlide);\n        this.selectInitialSlides();\n      }\n\n      if (this.customActiveSlide && !this.multilist) {\n        this._select(this.customActiveSlide);\n      }\n    }, 0);\n  }\n\n  ngOnDestroy() {\n    this.destroyed = true;\n  }\n  /**\n   * Adds new slide. If this slide is first in collection - set it as active\n   * and starts auto changing\n   * @param slide\n   */\n\n\n  addSlide(slide) {\n    this._slides.add(slide);\n\n    if (this.multilist && this._slides.length <= this.itemsPerSlide) {\n      slide.active = true;\n    }\n\n    if (!this.multilist && this.isAnimated) {\n      slide.isAnimated = true;\n    }\n\n    if (!this.multilist && this._slides.length === 1) {\n      this._currentActiveSlide = undefined;\n\n      if (!this.customActiveSlide) {\n        this.activeSlide = 0;\n      }\n\n      this.play();\n    }\n\n    if (this.multilist && this._slides.length > this.itemsPerSlide) {\n      this.play();\n    }\n  }\n  /**\n   * Removes specified slide. If this slide is active - will roll to another\n   * slide\n   * @param slide\n   */\n\n\n  removeSlide(slide) {\n    const remIndex = this._slides.indexOf(slide);\n\n    if (this._currentActiveSlide === remIndex) {\n      // removing of active slide\n      let nextSlideIndex;\n\n      if (this._slides.length > 1) {\n        // if this slide last - will roll to first slide, if noWrap flag is\n        // FALSE or to previous, if noWrap is TRUE in case, if this slide in\n        // middle of collection, index of next slide is same to removed\n        nextSlideIndex = !this.isLast(remIndex) ? remIndex : this.noWrap ? remIndex - 1 : 0;\n      }\n\n      this._slides.remove(remIndex); // prevents exception with changing some value after checking\n\n\n      setTimeout(() => {\n        this._select(nextSlideIndex);\n      }, 0);\n    } else {\n      this._slides.remove(remIndex);\n\n      const currentSlideIndex = this.getCurrentSlideIndex();\n      setTimeout(() => {\n        // after removing, need to actualize index of current active slide\n        this._currentActiveSlide = currentSlideIndex;\n        this.activeSlideChange.emit(this._currentActiveSlide);\n      }, 0);\n    }\n  }\n\n  nextSlideFromInterval(force = false) {\n    this.move(Direction.NEXT, force);\n  }\n  /**\n   * Rolling to next slide\n   * @param force: {boolean} if true - will ignore noWrap flag\n   */\n\n\n  nextSlide(force = false) {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n\n    this.move(Direction.NEXT, force);\n  }\n  /**\n   * Rolling to previous slide\n   * @param force: {boolean} if true - will ignore noWrap flag\n   */\n\n\n  previousSlide(force = false) {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n\n    this.move(Direction.PREV, force);\n  }\n\n  getFirstVisibleIndex() {\n    return this.slides.findIndex(this.getActive);\n  }\n\n  getLastVisibleIndex() {\n    return findLastIndex(this.slides, this.getActive);\n  }\n\n  move(direction, force = false) {\n    const firstVisibleIndex = this.getFirstVisibleIndex();\n    const lastVisibleIndex = this.getLastVisibleIndex();\n\n    if (this.noWrap) {\n      if (direction === Direction.NEXT && this.isLast(lastVisibleIndex) || direction === Direction.PREV && firstVisibleIndex === 0) {\n        return;\n      }\n    }\n\n    if (!this.multilist) {\n      this.activeSlide = this.findNextSlideIndex(direction, force) || 0;\n    } else {\n      this.moveMultilist(direction);\n    }\n  }\n  /**\n   * Swith slides by enter, space and arrows keys\n   * @internal\n   */\n\n\n  keydownPress(event) {\n    if (event.keyCode === 13 || event.key === 'Enter' || event.keyCode === 32 || event.key === 'Space') {\n      this.nextSlide();\n      event.preventDefault();\n      return;\n    }\n\n    if (event.keyCode === 37 || event.key === 'LeftArrow') {\n      this.previousSlide();\n      return;\n    }\n\n    if (event.keyCode === 39 || event.key === 'RightArrow') {\n      this.nextSlide();\n      return;\n    }\n  }\n  /**\n   * Play on mouse leave\n   * @internal\n   */\n\n\n  onMouseLeave() {\n    if (!this.pauseOnFocus) {\n      this.play();\n    }\n  }\n  /**\n   * Play on mouse up\n   * @internal\n   */\n\n\n  onMouseUp() {\n    if (!this.pauseOnFocus) {\n      this.play();\n    }\n  }\n  /**\n   * When slides on focus autoplay is stopped(optional)\n   * @internal\n   */\n\n\n  pauseFocusIn() {\n    if (this.pauseOnFocus) {\n      this.isPlaying = false;\n      this.resetTimer();\n    }\n  }\n  /**\n   * When slides out of focus autoplay is started\n   * @internal\n   */\n\n\n  pauseFocusOut() {\n    this.play();\n  }\n  /**\n   * Rolling to specified slide\n   * @param index: {number} index of slide, which must be shown\n   */\n\n\n  selectSlide(index) {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n\n    if (!this.multilist) {\n      this.activeSlide = this.indicatorsByChunk ? index * this.itemsPerSlide : index;\n    } else {\n      this.selectSlideRange(this.indicatorsByChunk ? index * this.itemsPerSlide : index);\n    }\n  }\n  /**\n   * Starts a auto changing of slides\n   */\n\n\n  play() {\n    if (!this.isPlaying) {\n      this.isPlaying = true;\n      this.restartTimer();\n    }\n  }\n  /**\n   * Stops a auto changing of slides\n   */\n\n\n  pause() {\n    if (!this.noPause) {\n      this.isPlaying = false;\n      this.resetTimer();\n    }\n  }\n  /**\n   * Finds and returns index of currently displayed slide\n   */\n\n\n  getCurrentSlideIndex() {\n    return this._slides.findIndex(this.getActive);\n  }\n  /**\n   * Defines, whether the specified index is last in collection\n   * @param index\n   */\n\n\n  isLast(index) {\n    return index + 1 >= this._slides.length;\n  }\n  /**\n   * Defines, whether the specified index is first in collection\n   * @param index\n   */\n\n\n  isFirst(index) {\n    return index === 0;\n  }\n\n  indicatorsSlides() {\n    return this.slides.filter((slide, index) => !this.indicatorsByChunk || index % this.itemsPerSlide === 0);\n  }\n\n  selectInitialSlides() {\n    const startIndex = this.startFromIndex <= this._slides.length ? this.startFromIndex : 0;\n    this.hideSlides();\n\n    if (this.singleSlideOffset) {\n      this._slidesWithIndexes = this.mapSlidesAndIndexes();\n\n      if (this._slides.length - startIndex < this.itemsPerSlide) {\n        const slidesToAppend = this._slidesWithIndexes.slice(0, startIndex);\n\n        this._slidesWithIndexes = [...this._slidesWithIndexes, ...slidesToAppend].slice(slidesToAppend.length).slice(0, this.itemsPerSlide);\n      } else {\n        this._slidesWithIndexes = this._slidesWithIndexes.slice(startIndex, startIndex + this.itemsPerSlide);\n      }\n\n      this._slidesWithIndexes.forEach(slide => slide.item.active = true);\n\n      this.makeSlidesConsistent(this._slidesWithIndexes);\n    } else {\n      this.selectRangeByNestedIndex(startIndex);\n    }\n\n    this.slideRangeChange.emit(this.getVisibleIndexes());\n  }\n  /**\n   * Defines next slide index, depending of direction\n   * @param direction: Direction(UNKNOWN|PREV|NEXT)\n   * @param force: {boolean} if TRUE - will ignore noWrap flag, else will\n   *   return undefined if next slide require wrapping\n   */\n\n\n  findNextSlideIndex(direction, force) {\n    let nextSlideIndex = 0;\n\n    if (!force && this.isLast(this.activeSlide) && direction !== Direction.PREV && this.noWrap) {\n      return;\n    }\n\n    switch (direction) {\n      case Direction.NEXT:\n        // if this is last slide, not force, looping is disabled\n        // and need to going forward - select current slide, as a next\n        if (typeof this._currentActiveSlide === 'undefined') {\n          nextSlideIndex = 0;\n          break;\n        }\n\n        if (!this.isLast(this._currentActiveSlide)) {\n          nextSlideIndex = this._currentActiveSlide + 1;\n          break;\n        }\n\n        nextSlideIndex = !force && this.noWrap ? this._currentActiveSlide : 0;\n        break;\n\n      case Direction.PREV:\n        // if this is first slide, not force, looping is disabled\n        // and need to going backward - select current slide, as a next\n        if (typeof this._currentActiveSlide === 'undefined') {\n          nextSlideIndex = 0;\n          break;\n        }\n\n        if (this._currentActiveSlide > 0) {\n          nextSlideIndex = this._currentActiveSlide - 1;\n          break;\n        }\n\n        if (!force && this.noWrap) {\n          nextSlideIndex = this._currentActiveSlide;\n          break;\n        }\n\n        nextSlideIndex = this._slides.length - 1;\n        break;\n\n      default:\n        throw new Error('Unknown direction');\n    }\n\n    return nextSlideIndex;\n  }\n\n  mapSlidesAndIndexes() {\n    return this.slides.slice().map((slide, index) => {\n      return {\n        index,\n        item: slide\n      };\n    });\n  }\n\n  selectSlideRange(index) {\n    if (this.isIndexInRange(index)) {\n      return;\n    }\n\n    this.hideSlides();\n\n    if (!this.singleSlideOffset) {\n      this.selectRangeByNestedIndex(index);\n    } else {\n      const startIndex = this.isIndexOnTheEdges(index) ? index : index - this.itemsPerSlide + 1;\n      const endIndex = this.isIndexOnTheEdges(index) ? index + this.itemsPerSlide : index + 1;\n      this._slidesWithIndexes = this.mapSlidesAndIndexes().slice(startIndex, endIndex);\n      this.makeSlidesConsistent(this._slidesWithIndexes);\n\n      this._slidesWithIndexes.forEach(slide => slide.item.active = true);\n    }\n\n    this.slideRangeChange.emit(this.getVisibleIndexes());\n  }\n\n  selectRangeByNestedIndex(index) {\n    if (!this._chunkedSlides) {\n      return;\n    }\n\n    const selectedRange = this._chunkedSlides.map((slidesList, i) => {\n      return {\n        index: i,\n        list: slidesList\n      };\n    }).find(slidesList => {\n      return slidesList.list.find(slide => slide.index === index) !== undefined;\n    });\n\n    if (!selectedRange) {\n      return;\n    }\n\n    this._currentVisibleSlidesIndex = selectedRange.index;\n\n    this._chunkedSlides[selectedRange.index].forEach(slide => {\n      slide.item.active = true;\n    });\n  }\n\n  isIndexOnTheEdges(index) {\n    return index + 1 - this.itemsPerSlide <= 0 || index + this.itemsPerSlide <= this._slides.length;\n  }\n\n  isIndexInRange(index) {\n    if (this.singleSlideOffset && this._slidesWithIndexes) {\n      const visibleIndexes = this._slidesWithIndexes.map(slide => slide.index);\n\n      return visibleIndexes.indexOf(index) >= 0;\n    }\n\n    return index <= this.getLastVisibleIndex() && index >= this.getFirstVisibleIndex();\n  }\n\n  hideSlides() {\n    this.slides.forEach(slide => slide.active = false);\n  }\n\n  isVisibleSlideListLast() {\n    if (!this._chunkedSlides) {\n      return false;\n    }\n\n    return this._currentVisibleSlidesIndex === this._chunkedSlides.length - 1;\n  }\n\n  isVisibleSlideListFirst() {\n    return this._currentVisibleSlidesIndex === 0;\n  }\n\n  moveSliderByOneItem(direction) {\n    let firstVisibleIndex;\n    let lastVisibleIndex;\n    let indexToHide;\n    let indexToShow;\n\n    if (this.noWrap) {\n      firstVisibleIndex = this.getFirstVisibleIndex();\n      lastVisibleIndex = this.getLastVisibleIndex();\n      indexToHide = direction === Direction.NEXT ? firstVisibleIndex : lastVisibleIndex;\n      indexToShow = direction !== Direction.NEXT ? firstVisibleIndex - 1 : !this.isLast(lastVisibleIndex) ? lastVisibleIndex + 1 : 0;\n\n      const slideToHide = this._slides.get(indexToHide);\n\n      if (slideToHide) {\n        slideToHide.active = false;\n      }\n\n      const slideToShow = this._slides.get(indexToShow);\n\n      if (slideToShow) {\n        slideToShow.active = true;\n      }\n\n      const slidesToReorder = this.mapSlidesAndIndexes().filter(slide => slide.item.active);\n      this.makeSlidesConsistent(slidesToReorder);\n\n      if (this.singleSlideOffset) {\n        this._slidesWithIndexes = slidesToReorder;\n      }\n\n      this.slideRangeChange.emit(this.getVisibleIndexes());\n      return;\n    }\n\n    if (!this._slidesWithIndexes || !this._slidesWithIndexes[0]) {\n      return;\n    }\n\n    let index;\n    firstVisibleIndex = this._slidesWithIndexes[0].index;\n    lastVisibleIndex = this._slidesWithIndexes[this._slidesWithIndexes.length - 1].index;\n\n    if (direction === Direction.NEXT) {\n      this._slidesWithIndexes.shift();\n\n      index = this.isLast(lastVisibleIndex) ? 0 : lastVisibleIndex + 1;\n\n      const item = this._slides.get(index);\n\n      if (item) {\n        this._slidesWithIndexes.push({\n          index,\n          item\n        });\n      }\n    } else {\n      this._slidesWithIndexes.pop();\n\n      index = this.isFirst(firstVisibleIndex) ? this._slides.length - 1 : firstVisibleIndex - 1;\n\n      const item = this._slides.get(index);\n\n      if (item) {\n        this._slidesWithIndexes = [{\n          index,\n          item\n        }, ...this._slidesWithIndexes];\n      }\n    }\n\n    this.hideSlides();\n\n    this._slidesWithIndexes.forEach(slide => slide.item.active = true);\n\n    this.makeSlidesConsistent(this._slidesWithIndexes);\n    this.slideRangeChange.emit(this._slidesWithIndexes.map(slide => slide.index));\n  }\n\n  moveMultilist(direction) {\n    if (this.singleSlideOffset) {\n      this.moveSliderByOneItem(direction);\n    } else {\n      this.hideSlides();\n\n      if (this.noWrap) {\n        this._currentVisibleSlidesIndex = direction === Direction.NEXT ? this._currentVisibleSlidesIndex + 1 : this._currentVisibleSlidesIndex - 1;\n      } else if (direction === Direction.NEXT) {\n        this._currentVisibleSlidesIndex = this.isVisibleSlideListLast() ? 0 : this._currentVisibleSlidesIndex + 1;\n      } else {\n        if (this.isVisibleSlideListFirst()) {\n          this._currentVisibleSlidesIndex = this._chunkedSlides ? this._chunkedSlides.length - 1 : 0;\n        } else {\n          this._currentVisibleSlidesIndex = this._currentVisibleSlidesIndex - 1;\n        }\n      }\n\n      if (this._chunkedSlides) {\n        this._chunkedSlides[this._currentVisibleSlidesIndex].forEach(slide => slide.item.active = true);\n      }\n\n      this.slideRangeChange.emit(this.getVisibleIndexes());\n    }\n  }\n\n  getVisibleIndexes() {\n    if (!this.singleSlideOffset && this._chunkedSlides) {\n      return this._chunkedSlides[this._currentVisibleSlidesIndex].map(slide => slide.index);\n    }\n\n    if (this._slidesWithIndexes) {\n      return this._slidesWithIndexes.map(slide => slide.index);\n    }\n  }\n  /**\n   * Sets a slide, which specified through index, as active\n   * @param index\n   */\n\n\n  _select(index) {\n    if (isNaN(index)) {\n      this.pause();\n      return;\n    }\n\n    if (!this.multilist && typeof this._currentActiveSlide !== 'undefined') {\n      const currentSlide = this._slides.get(this._currentActiveSlide);\n\n      if (typeof currentSlide !== 'undefined') {\n        currentSlide.active = false;\n      }\n    }\n\n    const nextSlide = this._slides.get(index);\n\n    if (typeof nextSlide !== 'undefined') {\n      this._currentActiveSlide = index;\n      nextSlide.active = true;\n      this.activeSlide = index;\n      this.activeSlideChange.emit(index);\n    }\n  }\n  /**\n   * Starts loop of auto changing of slides\n   */\n\n\n  restartTimer() {\n    this.resetTimer();\n    const interval = +this.interval;\n\n    if (!isNaN(interval) && interval > 0) {\n      this.currentInterval = this.ngZone.runOutsideAngular(() => {\n        return window.setInterval(() => {\n          const nInterval = +this.interval;\n          this.ngZone.run(() => {\n            if (this.isPlaying && !isNaN(this.interval) && nInterval > 0 && this.slides.length) {\n              this.nextSlideFromInterval();\n            } else {\n              this.pause();\n            }\n          });\n        }, interval);\n      });\n    }\n  }\n\n  get multilist() {\n    return this.itemsPerSlide > 1;\n  }\n  /**\n   * Stops loop of auto changing of slides\n   */\n\n\n  resetTimer() {\n    if (this.currentInterval) {\n      clearInterval(this.currentInterval);\n      this.currentInterval = void 0;\n    }\n  }\n\n  checkDisabledClass(buttonType) {\n    if (buttonType === 'prev') {\n      return this.activeSlide === 0 && this.noWrap && !this.multilist || this.isFirstSlideVisible && this.noWrap && this.multilist;\n    }\n\n    return this.isLast(this.activeSlide) && this.noWrap && !this.multilist || this.isLastSlideVisible && this.noWrap && this.multilist;\n  }\n\n}\n\nCarouselComponent.ɵfac = function CarouselComponent_Factory(t) {\n  return new (t || CarouselComponent)(i0.ɵɵdirectiveInject(CarouselConfig), i0.ɵɵdirectiveInject(i0.NgZone));\n};\n\nCarouselComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: CarouselComponent,\n  selectors: [[\"carousel\"]],\n  inputs: {\n    noWrap: \"noWrap\",\n    noPause: \"noPause\",\n    showIndicators: \"showIndicators\",\n    pauseOnFocus: \"pauseOnFocus\",\n    indicatorsByChunk: \"indicatorsByChunk\",\n    itemsPerSlide: \"itemsPerSlide\",\n    singleSlideOffset: \"singleSlideOffset\",\n    isAnimated: \"isAnimated\",\n    activeSlide: \"activeSlide\",\n    startFromIndex: \"startFromIndex\",\n    interval: \"interval\"\n  },\n  outputs: {\n    activeSlideChange: \"activeSlideChange\",\n    slideRangeChange: \"slideRangeChange\"\n  },\n  ngContentSelectors: _c1,\n  decls: 7,\n  vars: 8,\n  consts: [[\"tabindex\", \"0\", 1, \"carousel\", \"slide\", 3, \"id\", \"mouseenter\", \"mouseleave\", \"mouseup\", \"keydown\", \"focusin\", \"focusout\"], [4, \"ngIf\"], [1, \"carousel-inner\", 3, \"ngStyle\"], [\"class\", \"left carousel-control carousel-control-prev\", \"tabindex\", \"0\", \"role\", \"button\", 3, \"disabled\", \"click\", 4, \"ngIf\"], [\"class\", \"right carousel-control carousel-control-next\", \"tabindex\", \"0\", \"role\", \"button\", 3, \"disabled\", \"click\", 4, \"ngIf\"], [1, \"carousel-indicators\"], [3, \"active\", \"click\", 4, \"ngFor\", \"ngForOf\"], [3, \"click\"], [\"type\", \"button\", \"aria-current\", \"true\", 3, \"active\", \"click\", 4, \"ngFor\", \"ngForOf\"], [\"type\", \"button\", \"aria-current\", \"true\", 3, \"click\"], [\"tabindex\", \"0\", \"role\", \"button\", 1, \"left\", \"carousel-control\", \"carousel-control-prev\", 3, \"click\"], [\"aria-hidden\", \"true\", 1, \"icon-prev\", \"carousel-control-prev-icon\"], [\"class\", \"sr-only visually-hidden\", 4, \"ngIf\"], [1, \"sr-only\", \"visually-hidden\"], [\"tabindex\", \"0\", \"role\", \"button\", 1, \"right\", \"carousel-control\", \"carousel-control-next\", 3, \"click\"], [\"aria-hidden\", \"true\", 1, \"icon-next\", \"carousel-control-next-icon\"]],\n  template: function CarouselComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵprojectionDef();\n      i0.ɵɵelementStart(0, \"div\", 0);\n      i0.ɵɵlistener(\"mouseenter\", function CarouselComponent_Template_div_mouseenter_0_listener() {\n        return ctx.pause();\n      })(\"mouseleave\", function CarouselComponent_Template_div_mouseleave_0_listener() {\n        return ctx.onMouseLeave();\n      })(\"mouseup\", function CarouselComponent_Template_div_mouseup_0_listener() {\n        return ctx.onMouseUp();\n      })(\"keydown\", function CarouselComponent_Template_div_keydown_0_listener($event) {\n        return ctx.keydownPress($event);\n      })(\"focusin\", function CarouselComponent_Template_div_focusin_0_listener() {\n        return ctx.pauseFocusIn();\n      })(\"focusout\", function CarouselComponent_Template_div_focusout_0_listener() {\n        return ctx.pauseFocusOut();\n      });\n      i0.ɵɵtemplate(1, CarouselComponent_ng_container_1_Template, 3, 1, \"ng-container\", 1);\n      i0.ɵɵtemplate(2, CarouselComponent_ng_container_2_Template, 3, 1, \"ng-container\", 1);\n      i0.ɵɵelementStart(3, \"div\", 2);\n      i0.ɵɵprojection(4);\n      i0.ɵɵelementEnd();\n      i0.ɵɵtemplate(5, CarouselComponent_a_5_Template, 3, 4, \"a\", 3);\n      i0.ɵɵtemplate(6, CarouselComponent_a_6_Template, 4, 3, \"a\", 4);\n      i0.ɵɵelementEnd();\n    }\n\n    if (rf & 2) {\n      i0.ɵɵproperty(\"id\", ctx.currentId);\n      i0.ɵɵadvance(1);\n      i0.ɵɵproperty(\"ngIf\", !ctx._bsVer.isBs5 && ctx.showIndicators && ctx.slides.length > 1);\n      i0.ɵɵadvance(1);\n      i0.ɵɵproperty(\"ngIf\", ctx._bsVer.isBs5 && ctx.showIndicators && ctx.slides.length > 1);\n      i0.ɵɵadvance(1);\n      i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction1(6, _c0, ctx.multilist ? \"flex\" : \"block\"));\n      i0.ɵɵadvance(2);\n      i0.ɵɵproperty(\"ngIf\", ctx.slides.length > 1);\n      i0.ɵɵadvance(1);\n      i0.ɵɵproperty(\"ngIf\", ctx.slides.length > 1);\n    }\n  },\n  directives: [i2.NgIf, i2.NgStyle, i2.NgForOf],\n  encapsulation: 2\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CarouselComponent, [{\n    type: Component,\n    args: [{\n      selector: 'carousel',\n      template: \"<div (mouseenter)=\\\"pause()\\\"\\n     (mouseleave)=\\\"onMouseLeave()\\\"\\n     (mouseup)=\\\"onMouseUp()\\\"\\n     (keydown)=\\\"keydownPress($event)\\\"\\n     (focusin)=\\\"pauseFocusIn()\\\"\\n     (focusout)=\\\"pauseFocusOut()\\\"\\n     [id]=\\\"currentId\\\"\\n     class=\\\"carousel slide\\\" tabindex=\\\"0\\\">\\n  <ng-container *ngIf=\\\"!_bsVer.isBs5 && showIndicators && slides.length > 1\\\">\\n    <ol class=\\\"carousel-indicators\\\">\\n      <li *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n          [class.active]=\\\"slide.active === true\\\"\\n          (click)=\\\"selectSlide(i)\\\">\\n      </li>\\n    </ol>\\n  </ng-container>\\n  <ng-container *ngIf=\\\"_bsVer.isBs5 && showIndicators && slides.length > 1\\\">\\n    <div class=\\\"carousel-indicators\\\">\\n      <button\\n        *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n        [class.active]=\\\"slide.active === true\\\"\\n        (click)=\\\"selectSlide(i)\\\"\\n        type=\\\"button\\\"\\n        [attr.data-bs-target]=\\\"'#'+currentId\\\"\\n        [attr.data-bs-slide-to]=\\\"i\\\" aria-current=\\\"true\\\"\\n      >\\n      </button>\\n    </div>\\n  </ng-container>\\n  <div class=\\\"carousel-inner\\\" [ngStyle]=\\\"{'display': multilist ? 'flex' : 'block'}\\\">\\n    <ng-content></ng-content>\\n  </div>\\n  <a class=\\\"left carousel-control carousel-control-prev\\\"\\n     *ngIf=\\\"slides.length > 1\\\"\\n     [class.disabled]=\\\"checkDisabledClass('prev')\\\"\\n     [attr.data-bs-target]=\\\"'#'+currentId\\\"\\n     (click)=\\\"previousSlide()\\\"\\n      tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-prev carousel-control-prev-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span *ngIf=\\\"isBs4\\\" class=\\\"sr-only visually-hidden\\\">Previous</span>\\n  </a>\\n  <a class=\\\"right carousel-control carousel-control-next\\\"\\n     *ngIf=\\\"slides.length > 1\\\"\\n     [class.disabled]=\\\"checkDisabledClass('next')\\\"\\n     [attr.data-bs-target]=\\\"'#'+currentId\\\"\\n     (click)=\\\"nextSlide()\\\"\\n     tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-next carousel-control-next-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span class=\\\"sr-only visually-hidden\\\">Next</span>\\n  </a>\\n</div>\\n\"\n    }]\n  }], function () {\n    return [{\n      type: CarouselConfig\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    noWrap: [{\n      type: Input\n    }],\n    noPause: [{\n      type: Input\n    }],\n    showIndicators: [{\n      type: Input\n    }],\n    pauseOnFocus: [{\n      type: Input\n    }],\n    indicatorsByChunk: [{\n      type: Input\n    }],\n    itemsPerSlide: [{\n      type: Input\n    }],\n    singleSlideOffset: [{\n      type: Input\n    }],\n    isAnimated: [{\n      type: Input\n    }],\n    activeSlideChange: [{\n      type: Output\n    }],\n    slideRangeChange: [{\n      type: Output\n    }],\n    activeSlide: [{\n      type: Input\n    }],\n    startFromIndex: [{\n      type: Input\n    }],\n    interval: [{\n      type: Input\n    }]\n  });\n})();\n\nclass SlideComponent {\n  constructor(carousel) {\n    /** Is current slide active */\n    this.active = false;\n    this.itemWidth = '100%';\n    this.order = 0;\n    this.isAnimated = false;\n    /** Wraps element by appropriate CSS classes */\n\n    this.addClass = true;\n    this.multilist = false;\n    this.carousel = carousel;\n  }\n  /** Fires changes in container collection after adding a new slide instance */\n\n\n  ngOnInit() {\n    var _a;\n\n    this.carousel.addSlide(this);\n    this.itemWidth = `${100 / this.carousel.itemsPerSlide}%`;\n    this.multilist = ((_a = this.carousel) === null || _a === void 0 ? void 0 : _a.itemsPerSlide) > 1;\n  }\n  /** Fires changes in container collection after removing of this slide instance */\n\n\n  ngOnDestroy() {\n    this.carousel.removeSlide(this);\n  }\n\n}\n\nSlideComponent.ɵfac = function SlideComponent_Factory(t) {\n  return new (t || SlideComponent)(i0.ɵɵdirectiveInject(CarouselComponent));\n};\n\nSlideComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: SlideComponent,\n  selectors: [[\"slide\"]],\n  hostVars: 15,\n  hostBindings: function SlideComponent_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      i0.ɵɵattribute(\"aria-hidden\", !ctx.active);\n      i0.ɵɵstyleProp(\"width\", ctx.itemWidth)(\"order\", ctx.order);\n      i0.ɵɵclassProp(\"multilist-margin\", ctx.multilist)(\"active\", ctx.active)(\"carousel-animation\", ctx.isAnimated)(\"item\", ctx.addClass)(\"carousel-item\", ctx.addClass);\n    }\n  },\n  inputs: {\n    active: \"active\"\n  },\n  ngContentSelectors: _c1,\n  decls: 2,\n  vars: 2,\n  consts: [[1, \"item\"]],\n  template: function SlideComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵprojectionDef();\n      i0.ɵɵelementStart(0, \"div\", 0);\n      i0.ɵɵprojection(1);\n      i0.ɵɵelementEnd();\n    }\n\n    if (rf & 2) {\n      i0.ɵɵclassProp(\"active\", ctx.active);\n    }\n  },\n  styles: [\".carousel-animation[_nghost-%COMP%]{transition:opacity .6s ease,visibility .6s ease;float:left}.carousel-animation.active[_nghost-%COMP%]{opacity:1;visibility:visible}.carousel-animation[_nghost-%COMP%]:not(.active){display:block;position:absolute;opacity:0;visibility:hidden}.multilist-margin[_nghost-%COMP%]{margin-right:auto}.carousel-item[_nghost-%COMP%]{perspective:1000px}\"]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SlideComponent, [{\n    type: Component,\n    args: [{\n      selector: 'slide',\n      template: `\n    <div [class.active]=\"active\" class=\"item\">\n      <ng-content></ng-content>\n    </div>\n  `,\n      // eslint-disable-next-line @angular-eslint/no-host-metadata-property\n      host: {\n        '[attr.aria-hidden]': '!active',\n        '[class.multilist-margin]': 'multilist'\n      },\n      styles: [`\n    :host.carousel-animation {\n       transition: opacity 0.6s ease, visibility 0.6s ease;\n       float: left;\n    }\n    :host.carousel-animation.active {\n      opacity: 1;\n      visibility: visible;\n    }\n    :host.carousel-animation:not(.active) {\n      display: block;\n      position: absolute;\n      opacity: 0;\n      visibility: hidden;\n    }\n    :host.multilist-margin {\n      margin-right: auto;\n    }\n    :host.carousel-item {\n      perspective: 1000px;\n    }\n  `]\n    }]\n  }], function () {\n    return [{\n      type: CarouselComponent\n    }];\n  }, {\n    active: [{\n      type: HostBinding,\n      args: ['class.active']\n    }, {\n      type: Input\n    }],\n    itemWidth: [{\n      type: HostBinding,\n      args: ['style.width']\n    }],\n    order: [{\n      type: HostBinding,\n      args: ['style.order']\n    }],\n    isAnimated: [{\n      type: HostBinding,\n      args: ['class.carousel-animation']\n    }],\n    addClass: [{\n      type: HostBinding,\n      args: ['class.item']\n    }, {\n      type: HostBinding,\n      args: ['class.carousel-item']\n    }]\n  });\n})();\n\nclass CarouselModule {\n  static forRoot() {\n    return {\n      ngModule: CarouselModule,\n      providers: []\n    };\n  }\n\n}\n\nCarouselModule.ɵfac = function CarouselModule_Factory(t) {\n  return new (t || CarouselModule)();\n};\n\nCarouselModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: CarouselModule\n});\nCarouselModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[CommonModule]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CarouselModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule],\n      declarations: [SlideComponent, CarouselComponent],\n      exports: [SlideComponent, CarouselComponent]\n    }]\n  }], null, null);\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { CarouselComponent, CarouselConfig, CarouselModule, SlideComponent };","map":{"version":3,"sources":["C:/Users/Fernando/Códigos/SA-SEL/Site Bixos 2024/site-bixos-2024/node_modules/ngx-bootstrap/carousel/fesm2015/ngx-bootstrap-carousel.mjs"],"names":["i0","Injectable","EventEmitter","Component","Input","Output","HostBinding","NgModule","LinkedList","isBs3","getBsVer","i2","CommonModule","findLastIndex","array","predicate","l","length","chunkByNumber","size","out","n","Math","ceil","i","chunk","splice","push","isNumber","value","Object","prototype","toString","call","CarouselConfig","constructor","interval","noPause","noWrap","showIndicators","pauseOnFocus","indicatorsByChunk","itemsPerSlide","singleSlideOffset","ɵfac","ɵprov","type","args","providedIn","Direction","_currentId","CarouselComponent","config","ngZone","isAnimated","activeSlideChange","slideRangeChange","startFromIndex","_interval","_slides","_currentVisibleSlidesIndex","isPlaying","destroyed","currentId","getActive","slide","active","makeSlidesConsistent","slides","forEach","index","item","order","assign","activeSlide","multilist","customActiveSlide","_currentActiveSlide","_select","restartTimer","toArray","isFirstSlideVisible","indexes","getVisibleIndexes","Array","includes","isLastSlideVisible","isBs4","_bsVer","ngAfterViewInit","setTimeout","_chunkedSlides","mapSlidesAndIndexes","selectInitialSlides","ngOnDestroy","addSlide","add","undefined","play","removeSlide","remIndex","indexOf","nextSlideIndex","isLast","remove","currentSlideIndex","getCurrentSlideIndex","emit","nextSlideFromInterval","force","move","NEXT","nextSlide","previousSlide","PREV","getFirstVisibleIndex","findIndex","getLastVisibleIndex","direction","firstVisibleIndex","lastVisibleIndex","findNextSlideIndex","moveMultilist","keydownPress","event","keyCode","key","preventDefault","onMouseLeave","onMouseUp","pauseFocusIn","resetTimer","pauseFocusOut","selectSlide","selectSlideRange","pause","isFirst","indicatorsSlides","filter","startIndex","hideSlides","_slidesWithIndexes","slidesToAppend","slice","selectRangeByNestedIndex","Error","map","isIndexInRange","isIndexOnTheEdges","endIndex","selectedRange","slidesList","list","find","visibleIndexes","isVisibleSlideListLast","isVisibleSlideListFirst","moveSliderByOneItem","indexToHide","indexToShow","slideToHide","get","slideToShow","slidesToReorder","shift","pop","isNaN","currentSlide","currentInterval","runOutsideAngular","window","setInterval","nInterval","run","clearInterval","checkDisabledClass","buttonType","NgZone","ɵcmp","NgIf","NgStyle","NgForOf","selector","template","SlideComponent","carousel","itemWidth","addClass","ngOnInit","_a","host","styles","CarouselModule","forRoot","ngModule","providers","ɵmod","ɵinj","imports","declarations","exports"],"mappings":"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","sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, Component, Input, Output, HostBinding, NgModule } from '@angular/core';\nimport { LinkedList, isBs3, getBsVer } from 'ngx-bootstrap/utils';\nimport * as i2 from '@angular/common';\nimport { CommonModule } from '@angular/common';\n\n/**\n * Returns the index of the last element in the array where predicate is true, and -1\n * otherwise.\n * @param array The source array to search in\n * @param predicate find calls predicate once for each element of the array, in descending\n * order, until it finds one where predicate returns true. If such an element is found,\n * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n */\nfunction findLastIndex(array, predicate) {\n    let l = array.length;\n    while (l--) {\n        if (predicate(array[l], l, array)) {\n            return l;\n        }\n    }\n    return -1;\n}\nfunction chunkByNumber(array, size) {\n    const out = [];\n    const n = Math.ceil((array.length) / size);\n    let i = 0;\n    while (i < n) {\n        const chunk = array.splice(0, (i === n - 1) && size < array.length ? array.length : size);\n        out.push(chunk);\n        i++;\n    }\n    return out;\n}\nfunction isNumber(value) {\n    return typeof value === 'number' || Object.prototype.toString.call(value) === '[object Number]';\n}\n\nclass CarouselConfig {\n    constructor() {\n        /* Default interval of auto changing of slides */\n        this.interval = 5000;\n        /* Is loop of auto changing of slides can be paused */\n        this.noPause = false;\n        /* Is slides can wrap from the last to the first slide */\n        this.noWrap = false;\n        /* Show carousel-indicators */\n        this.showIndicators = true;\n        /* Slides can be paused on focus */\n        this.pauseOnFocus = false;\n        /* If `true` - carousel indicators indicate slides chunks works ONLY if singleSlideOffset = FALSE */\n        this.indicatorsByChunk = false;\n        /* If value more then 1 — carousel works in multilist mode */\n        this.itemsPerSlide = 1;\n        /* If `true` — carousel shifts by one element. By default carousel shifts by number\n          of visible elements (itemsPerSlide field) */\n        this.singleSlideOffset = false;\n    }\n}\nCarouselConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: CarouselConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nCarouselConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: CarouselConfig, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: CarouselConfig, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }] });\n\n/***\n * pause (not yet supported) (?string='hover') - event group name which pauses\n * the cycling of the carousel, if hover pauses on mouseenter and resumes on\n * mouseleave keyboard (not yet supported) (?boolean=true) - if false\n * carousel will not react to keyboard events\n * note: swiping not yet supported\n */\nvar Direction;\n(function (Direction) {\n    Direction[Direction[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    Direction[Direction[\"NEXT\"] = 1] = \"NEXT\";\n    Direction[Direction[\"PREV\"] = 2] = \"PREV\";\n})(Direction || (Direction = {}));\nlet _currentId = 1;\n/**\n * Base element to create carousel\n */\nclass CarouselComponent {\n    constructor(config, ngZone) {\n        this.ngZone = ngZone;\n        /* If `true` — carousel will not cycle continuously and will have hard stops (prevent looping) */\n        this.noWrap = false;\n        /*  If `true` — will disable pausing on carousel mouse hover */\n        this.noPause = false;\n        /*  If `true` — carousel-indicators are visible  */\n        this.showIndicators = true;\n        /*  If `true` - autoplay will be stopped on focus */\n        this.pauseOnFocus = false;\n        /* If `true` - carousel indicators indicate slides chunks\n           works ONLY if singleSlideOffset = FALSE */\n        this.indicatorsByChunk = false;\n        /* If value more then 1 — carousel works in multilist mode */\n        this.itemsPerSlide = 1;\n        /* If `true` — carousel shifts by one element. By default carousel shifts by number\n           of visible elements (itemsPerSlide field) */\n        this.singleSlideOffset = false;\n        /** Turn on/off animation. Animation doesn't work for multilist carousel */\n        this.isAnimated = false;\n        /** Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property */\n        this.activeSlideChange = new EventEmitter(false);\n        /** Will be emitted when active slides has been changed in multilist mode */\n        this.slideRangeChange = new EventEmitter();\n        /* Index to start display slides from it */\n        this.startFromIndex = 0;\n        this._interval = 5000;\n        this._slides = new LinkedList();\n        this._currentVisibleSlidesIndex = 0;\n        this.isPlaying = false;\n        this.destroyed = false;\n        this.currentId = 0;\n        this.getActive = (slide) => slide.active;\n        this.makeSlidesConsistent = (slides) => {\n            slides.forEach((slide, index) => slide.item.order = index);\n        };\n        Object.assign(this, config);\n        this.currentId = _currentId++;\n    }\n    /** Index of currently displayed slide(started for 0) */\n    set activeSlide(index) {\n        if (this.multilist) {\n            return;\n        }\n        if (isNumber(index)) {\n            this.customActiveSlide = index;\n        }\n        if (this._slides.length && index !== this._currentActiveSlide) {\n            this._select(index);\n        }\n    }\n    get activeSlide() {\n        return this._currentActiveSlide || 0;\n    }\n    /**\n     * Delay of item cycling in milliseconds. If false, carousel won't cycle\n     * automatically.\n     */\n    get interval() {\n        return this._interval;\n    }\n    set interval(value) {\n        this._interval = value;\n        this.restartTimer();\n    }\n    get slides() {\n        return this._slides.toArray();\n    }\n    get isFirstSlideVisible() {\n        const indexes = this.getVisibleIndexes();\n        if (!indexes || (indexes instanceof Array && !indexes.length)) {\n            return false;\n        }\n        return indexes.includes(0);\n    }\n    get isLastSlideVisible() {\n        const indexes = this.getVisibleIndexes();\n        if (!indexes || (indexes instanceof Array && !indexes.length)) {\n            return false;\n        }\n        return indexes.includes(this._slides.length - 1);\n    }\n    get isBs4() {\n        return !isBs3();\n    }\n    get _bsVer() {\n        return getBsVer();\n    }\n    ngAfterViewInit() {\n        setTimeout(() => {\n            if (this.singleSlideOffset) {\n                this.indicatorsByChunk = false;\n            }\n            if (this.multilist) {\n                this._chunkedSlides = chunkByNumber(this.mapSlidesAndIndexes(), this.itemsPerSlide);\n                this.selectInitialSlides();\n            }\n            if (this.customActiveSlide && !this.multilist) {\n                this._select(this.customActiveSlide);\n            }\n        }, 0);\n    }\n    ngOnDestroy() {\n        this.destroyed = true;\n    }\n    /**\n     * Adds new slide. If this slide is first in collection - set it as active\n     * and starts auto changing\n     * @param slide\n     */\n    addSlide(slide) {\n        this._slides.add(slide);\n        if (this.multilist && this._slides.length <= this.itemsPerSlide) {\n            slide.active = true;\n        }\n        if (!this.multilist && this.isAnimated) {\n            slide.isAnimated = true;\n        }\n        if (!this.multilist && this._slides.length === 1) {\n            this._currentActiveSlide = undefined;\n            if (!this.customActiveSlide) {\n                this.activeSlide = 0;\n            }\n            this.play();\n        }\n        if (this.multilist && this._slides.length > this.itemsPerSlide) {\n            this.play();\n        }\n    }\n    /**\n     * Removes specified slide. If this slide is active - will roll to another\n     * slide\n     * @param slide\n     */\n    removeSlide(slide) {\n        const remIndex = this._slides.indexOf(slide);\n        if (this._currentActiveSlide === remIndex) {\n            // removing of active slide\n            let nextSlideIndex;\n            if (this._slides.length > 1) {\n                // if this slide last - will roll to first slide, if noWrap flag is\n                // FALSE or to previous, if noWrap is TRUE in case, if this slide in\n                // middle of collection, index of next slide is same to removed\n                nextSlideIndex = !this.isLast(remIndex)\n                    ? remIndex\n                    : this.noWrap ? remIndex - 1 : 0;\n            }\n            this._slides.remove(remIndex);\n            // prevents exception with changing some value after checking\n            setTimeout(() => {\n                this._select(nextSlideIndex);\n            }, 0);\n        }\n        else {\n            this._slides.remove(remIndex);\n            const currentSlideIndex = this.getCurrentSlideIndex();\n            setTimeout(() => {\n                // after removing, need to actualize index of current active slide\n                this._currentActiveSlide = currentSlideIndex;\n                this.activeSlideChange.emit(this._currentActiveSlide);\n            }, 0);\n        }\n    }\n    nextSlideFromInterval(force = false) {\n        this.move(Direction.NEXT, force);\n    }\n    /**\n     * Rolling to next slide\n     * @param force: {boolean} if true - will ignore noWrap flag\n     */\n    nextSlide(force = false) {\n        if (this.isPlaying) {\n            this.restartTimer();\n        }\n        this.move(Direction.NEXT, force);\n    }\n    /**\n     * Rolling to previous slide\n     * @param force: {boolean} if true - will ignore noWrap flag\n     */\n    previousSlide(force = false) {\n        if (this.isPlaying) {\n            this.restartTimer();\n        }\n        this.move(Direction.PREV, force);\n    }\n    getFirstVisibleIndex() {\n        return this.slides.findIndex(this.getActive);\n    }\n    getLastVisibleIndex() {\n        return findLastIndex(this.slides, this.getActive);\n    }\n    move(direction, force = false) {\n        const firstVisibleIndex = this.getFirstVisibleIndex();\n        const lastVisibleIndex = this.getLastVisibleIndex();\n        if (this.noWrap) {\n            if (direction === Direction.NEXT &&\n                this.isLast(lastVisibleIndex) ||\n                direction === Direction.PREV &&\n                    firstVisibleIndex === 0) {\n                return;\n            }\n        }\n        if (!this.multilist) {\n            this.activeSlide = this.findNextSlideIndex(direction, force) || 0;\n        }\n        else {\n            this.moveMultilist(direction);\n        }\n    }\n    /**\n     * Swith slides by enter, space and arrows keys\n     * @internal\n     */\n    keydownPress(event) {\n        if (event.keyCode === 13 || event.key === 'Enter' || event.keyCode === 32 || event.key === 'Space') {\n            this.nextSlide();\n            event.preventDefault();\n            return;\n        }\n        if (event.keyCode === 37 || event.key === 'LeftArrow') {\n            this.previousSlide();\n            return;\n        }\n        if (event.keyCode === 39 || event.key === 'RightArrow') {\n            this.nextSlide();\n            return;\n        }\n    }\n    /**\n     * Play on mouse leave\n     * @internal\n     */\n    onMouseLeave() {\n        if (!this.pauseOnFocus) {\n            this.play();\n        }\n    }\n    /**\n     * Play on mouse up\n     * @internal\n     */\n    onMouseUp() {\n        if (!this.pauseOnFocus) {\n            this.play();\n        }\n    }\n    /**\n     * When slides on focus autoplay is stopped(optional)\n     * @internal\n     */\n    pauseFocusIn() {\n        if (this.pauseOnFocus) {\n            this.isPlaying = false;\n            this.resetTimer();\n        }\n    }\n    /**\n     * When slides out of focus autoplay is started\n     * @internal\n     */\n    pauseFocusOut() {\n        this.play();\n    }\n    /**\n     * Rolling to specified slide\n     * @param index: {number} index of slide, which must be shown\n     */\n    selectSlide(index) {\n        if (this.isPlaying) {\n            this.restartTimer();\n        }\n        if (!this.multilist) {\n            this.activeSlide = this.indicatorsByChunk ? index * this.itemsPerSlide : index;\n        }\n        else {\n            this.selectSlideRange(this.indicatorsByChunk ? index * this.itemsPerSlide : index);\n        }\n    }\n    /**\n     * Starts a auto changing of slides\n     */\n    play() {\n        if (!this.isPlaying) {\n            this.isPlaying = true;\n            this.restartTimer();\n        }\n    }\n    /**\n     * Stops a auto changing of slides\n     */\n    pause() {\n        if (!this.noPause) {\n            this.isPlaying = false;\n            this.resetTimer();\n        }\n    }\n    /**\n     * Finds and returns index of currently displayed slide\n     */\n    getCurrentSlideIndex() {\n        return this._slides.findIndex(this.getActive);\n    }\n    /**\n     * Defines, whether the specified index is last in collection\n     * @param index\n     */\n    isLast(index) {\n        return index + 1 >= this._slides.length;\n    }\n    /**\n     * Defines, whether the specified index is first in collection\n     * @param index\n     */\n    isFirst(index) {\n        return index === 0;\n    }\n    indicatorsSlides() {\n        return this.slides.filter((slide, index) => !this.indicatorsByChunk || index % this.itemsPerSlide === 0);\n    }\n    selectInitialSlides() {\n        const startIndex = this.startFromIndex <= this._slides.length\n            ? this.startFromIndex\n            : 0;\n        this.hideSlides();\n        if (this.singleSlideOffset) {\n            this._slidesWithIndexes = this.mapSlidesAndIndexes();\n            if (this._slides.length - startIndex < this.itemsPerSlide) {\n                const slidesToAppend = this._slidesWithIndexes.slice(0, startIndex);\n                this._slidesWithIndexes = [\n                    ...this._slidesWithIndexes,\n                    ...slidesToAppend\n                ]\n                    .slice(slidesToAppend.length)\n                    .slice(0, this.itemsPerSlide);\n            }\n            else {\n                this._slidesWithIndexes = this._slidesWithIndexes.slice(startIndex, startIndex + this.itemsPerSlide);\n            }\n            this._slidesWithIndexes.forEach((slide) => slide.item.active = true);\n            this.makeSlidesConsistent(this._slidesWithIndexes);\n        }\n        else {\n            this.selectRangeByNestedIndex(startIndex);\n        }\n        this.slideRangeChange.emit(this.getVisibleIndexes());\n    }\n    /**\n     * Defines next slide index, depending of direction\n     * @param direction: Direction(UNKNOWN|PREV|NEXT)\n     * @param force: {boolean} if TRUE - will ignore noWrap flag, else will\n     *   return undefined if next slide require wrapping\n     */\n    findNextSlideIndex(direction, force) {\n        let nextSlideIndex = 0;\n        if (!force &&\n            (this.isLast(this.activeSlide) &&\n                direction !== Direction.PREV &&\n                this.noWrap)) {\n            return;\n        }\n        switch (direction) {\n            case Direction.NEXT:\n                // if this is last slide, not force, looping is disabled\n                // and need to going forward - select current slide, as a next\n                if (typeof this._currentActiveSlide === 'undefined') {\n                    nextSlideIndex = 0;\n                    break;\n                }\n                if (!this.isLast(this._currentActiveSlide)) {\n                    nextSlideIndex = this._currentActiveSlide + 1;\n                    break;\n                }\n                nextSlideIndex = !force && this.noWrap ? this._currentActiveSlide : 0;\n                break;\n            case Direction.PREV:\n                // if this is first slide, not force, looping is disabled\n                // and need to going backward - select current slide, as a next\n                if (typeof this._currentActiveSlide === 'undefined') {\n                    nextSlideIndex = 0;\n                    break;\n                }\n                if (this._currentActiveSlide > 0) {\n                    nextSlideIndex = this._currentActiveSlide - 1;\n                    break;\n                }\n                if (!force && this.noWrap) {\n                    nextSlideIndex = this._currentActiveSlide;\n                    break;\n                }\n                nextSlideIndex = this._slides.length - 1;\n                break;\n            default:\n                throw new Error('Unknown direction');\n        }\n        return nextSlideIndex;\n    }\n    mapSlidesAndIndexes() {\n        return this.slides\n            .slice()\n            .map((slide, index) => {\n            return {\n                index,\n                item: slide\n            };\n        });\n    }\n    selectSlideRange(index) {\n        if (this.isIndexInRange(index)) {\n            return;\n        }\n        this.hideSlides();\n        if (!this.singleSlideOffset) {\n            this.selectRangeByNestedIndex(index);\n        }\n        else {\n            const startIndex = this.isIndexOnTheEdges(index)\n                ? index\n                : index - this.itemsPerSlide + 1;\n            const endIndex = this.isIndexOnTheEdges(index)\n                ? index + this.itemsPerSlide\n                : index + 1;\n            this._slidesWithIndexes = this.mapSlidesAndIndexes().slice(startIndex, endIndex);\n            this.makeSlidesConsistent(this._slidesWithIndexes);\n            this._slidesWithIndexes.forEach((slide) => slide.item.active = true);\n        }\n        this.slideRangeChange.emit(this.getVisibleIndexes());\n    }\n    selectRangeByNestedIndex(index) {\n        if (!this._chunkedSlides) {\n            return;\n        }\n        const selectedRange = this._chunkedSlides\n            .map((slidesList, i) => {\n            return {\n                index: i,\n                list: slidesList\n            };\n        })\n            .find((slidesList) => {\n            return slidesList.list.find(slide => slide.index === index) !== undefined;\n        });\n        if (!selectedRange) {\n            return;\n        }\n        this._currentVisibleSlidesIndex = selectedRange.index;\n        this._chunkedSlides[selectedRange.index].forEach((slide) => {\n            slide.item.active = true;\n        });\n    }\n    isIndexOnTheEdges(index) {\n        return (index + 1 - this.itemsPerSlide <= 0 ||\n            index + this.itemsPerSlide <= this._slides.length);\n    }\n    isIndexInRange(index) {\n        if (this.singleSlideOffset && this._slidesWithIndexes) {\n            const visibleIndexes = this._slidesWithIndexes.map((slide) => slide.index);\n            return visibleIndexes.indexOf(index) >= 0;\n        }\n        return (index <= this.getLastVisibleIndex() &&\n            index >= this.getFirstVisibleIndex());\n    }\n    hideSlides() {\n        this.slides.forEach((slide) => slide.active = false);\n    }\n    isVisibleSlideListLast() {\n        if (!this._chunkedSlides) {\n            return false;\n        }\n        return this._currentVisibleSlidesIndex === this._chunkedSlides.length - 1;\n    }\n    isVisibleSlideListFirst() {\n        return this._currentVisibleSlidesIndex === 0;\n    }\n    moveSliderByOneItem(direction) {\n        let firstVisibleIndex;\n        let lastVisibleIndex;\n        let indexToHide;\n        let indexToShow;\n        if (this.noWrap) {\n            firstVisibleIndex = this.getFirstVisibleIndex();\n            lastVisibleIndex = this.getLastVisibleIndex();\n            indexToHide = direction === Direction.NEXT\n                ? firstVisibleIndex\n                : lastVisibleIndex;\n            indexToShow = direction !== Direction.NEXT\n                ? firstVisibleIndex - 1\n                : !this.isLast(lastVisibleIndex)\n                    ? lastVisibleIndex + 1 : 0;\n            const slideToHide = this._slides.get(indexToHide);\n            if (slideToHide) {\n                slideToHide.active = false;\n            }\n            const slideToShow = this._slides.get(indexToShow);\n            if (slideToShow) {\n                slideToShow.active = true;\n            }\n            const slidesToReorder = this.mapSlidesAndIndexes().filter((slide) => slide.item.active);\n            this.makeSlidesConsistent(slidesToReorder);\n            if (this.singleSlideOffset) {\n                this._slidesWithIndexes = slidesToReorder;\n            }\n            this.slideRangeChange.emit(this.getVisibleIndexes());\n            return;\n        }\n        if (!this._slidesWithIndexes || !this._slidesWithIndexes[0]) {\n            return;\n        }\n        let index;\n        firstVisibleIndex = this._slidesWithIndexes[0].index;\n        lastVisibleIndex = this._slidesWithIndexes[this._slidesWithIndexes.length - 1].index;\n        if (direction === Direction.NEXT) {\n            this._slidesWithIndexes.shift();\n            index = this.isLast(lastVisibleIndex)\n                ? 0\n                : lastVisibleIndex + 1;\n            const item = this._slides.get(index);\n            if (item) {\n                this._slidesWithIndexes.push({ index, item });\n            }\n        }\n        else {\n            this._slidesWithIndexes.pop();\n            index = this.isFirst(firstVisibleIndex)\n                ? this._slides.length - 1\n                : firstVisibleIndex - 1;\n            const item = this._slides.get(index);\n            if (item) {\n                this._slidesWithIndexes = [{ index, item }, ...this._slidesWithIndexes];\n            }\n        }\n        this.hideSlides();\n        this._slidesWithIndexes.forEach(slide => slide.item.active = true);\n        this.makeSlidesConsistent(this._slidesWithIndexes);\n        this.slideRangeChange.emit(this._slidesWithIndexes.map((slide) => slide.index));\n    }\n    moveMultilist(direction) {\n        if (this.singleSlideOffset) {\n            this.moveSliderByOneItem(direction);\n        }\n        else {\n            this.hideSlides();\n            if (this.noWrap) {\n                this._currentVisibleSlidesIndex = direction === Direction.NEXT\n                    ? this._currentVisibleSlidesIndex + 1\n                    : this._currentVisibleSlidesIndex - 1;\n            }\n            else if (direction === Direction.NEXT) {\n                this._currentVisibleSlidesIndex = this.isVisibleSlideListLast()\n                    ? 0\n                    : this._currentVisibleSlidesIndex + 1;\n            }\n            else {\n                if (this.isVisibleSlideListFirst()) {\n                    this._currentVisibleSlidesIndex = this._chunkedSlides\n                        ? this._chunkedSlides.length - 1\n                        : 0;\n                }\n                else {\n                    this._currentVisibleSlidesIndex = this._currentVisibleSlidesIndex - 1;\n                }\n            }\n            if (this._chunkedSlides) {\n                this._chunkedSlides[this._currentVisibleSlidesIndex].forEach((slide) => slide.item.active = true);\n            }\n            this.slideRangeChange.emit(this.getVisibleIndexes());\n        }\n    }\n    getVisibleIndexes() {\n        if (!this.singleSlideOffset && this._chunkedSlides) {\n            return this._chunkedSlides[this._currentVisibleSlidesIndex]\n                .map((slide) => slide.index);\n        }\n        if (this._slidesWithIndexes) {\n            return this._slidesWithIndexes.map((slide) => slide.index);\n        }\n    }\n    /**\n     * Sets a slide, which specified through index, as active\n     * @param index\n     */\n    _select(index) {\n        if (isNaN(index)) {\n            this.pause();\n            return;\n        }\n        if (!this.multilist && typeof this._currentActiveSlide !== 'undefined') {\n            const currentSlide = this._slides.get(this._currentActiveSlide);\n            if (typeof currentSlide !== 'undefined') {\n                currentSlide.active = false;\n            }\n        }\n        const nextSlide = this._slides.get(index);\n        if (typeof nextSlide !== 'undefined') {\n            this._currentActiveSlide = index;\n            nextSlide.active = true;\n            this.activeSlide = index;\n            this.activeSlideChange.emit(index);\n        }\n    }\n    /**\n     * Starts loop of auto changing of slides\n     */\n    restartTimer() {\n        this.resetTimer();\n        const interval = +this.interval;\n        if (!isNaN(interval) && interval > 0) {\n            this.currentInterval = this.ngZone.runOutsideAngular(() => {\n                return window.setInterval(() => {\n                    const nInterval = +this.interval;\n                    this.ngZone.run(() => {\n                        if (this.isPlaying &&\n                            !isNaN(this.interval) &&\n                            nInterval > 0 &&\n                            this.slides.length) {\n                            this.nextSlideFromInterval();\n                        }\n                        else {\n                            this.pause();\n                        }\n                    });\n                }, interval);\n            });\n        }\n    }\n    get multilist() {\n        return this.itemsPerSlide > 1;\n    }\n    /**\n     * Stops loop of auto changing of slides\n     */\n    resetTimer() {\n        if (this.currentInterval) {\n            clearInterval(this.currentInterval);\n            this.currentInterval = void 0;\n        }\n    }\n    checkDisabledClass(buttonType) {\n        if (buttonType === 'prev') {\n            return (this.activeSlide === 0 && this.noWrap && !this.multilist) || (this.isFirstSlideVisible && this.noWrap && this.multilist);\n        }\n        return (this.isLast(this.activeSlide) && this.noWrap && !this.multilist) || (this.isLastSlideVisible && this.noWrap && this.multilist);\n    }\n}\nCarouselComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: CarouselComponent, deps: [{ token: CarouselConfig }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });\nCarouselComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.1.1\", type: CarouselComponent, selector: \"carousel\", inputs: { noWrap: \"noWrap\", noPause: \"noPause\", showIndicators: \"showIndicators\", pauseOnFocus: \"pauseOnFocus\", indicatorsByChunk: \"indicatorsByChunk\", itemsPerSlide: \"itemsPerSlide\", singleSlideOffset: \"singleSlideOffset\", isAnimated: \"isAnimated\", activeSlide: \"activeSlide\", startFromIndex: \"startFromIndex\", interval: \"interval\" }, outputs: { activeSlideChange: \"activeSlideChange\", slideRangeChange: \"slideRangeChange\" }, ngImport: i0, template: \"<div (mouseenter)=\\\"pause()\\\"\\n     (mouseleave)=\\\"onMouseLeave()\\\"\\n     (mouseup)=\\\"onMouseUp()\\\"\\n     (keydown)=\\\"keydownPress($event)\\\"\\n     (focusin)=\\\"pauseFocusIn()\\\"\\n     (focusout)=\\\"pauseFocusOut()\\\"\\n     [id]=\\\"currentId\\\"\\n     class=\\\"carousel slide\\\" tabindex=\\\"0\\\">\\n  <ng-container *ngIf=\\\"!_bsVer.isBs5 && showIndicators && slides.length > 1\\\">\\n    <ol class=\\\"carousel-indicators\\\">\\n      <li *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n          [class.active]=\\\"slide.active === true\\\"\\n          (click)=\\\"selectSlide(i)\\\">\\n      </li>\\n    </ol>\\n  </ng-container>\\n  <ng-container *ngIf=\\\"_bsVer.isBs5 && showIndicators && slides.length > 1\\\">\\n    <div class=\\\"carousel-indicators\\\">\\n      <button\\n        *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n        [class.active]=\\\"slide.active === true\\\"\\n        (click)=\\\"selectSlide(i)\\\"\\n        type=\\\"button\\\"\\n        [attr.data-bs-target]=\\\"'#'+currentId\\\"\\n        [attr.data-bs-slide-to]=\\\"i\\\" aria-current=\\\"true\\\"\\n      >\\n      </button>\\n    </div>\\n  </ng-container>\\n  <div class=\\\"carousel-inner\\\" [ngStyle]=\\\"{'display': multilist ? 'flex' : 'block'}\\\">\\n    <ng-content></ng-content>\\n  </div>\\n  <a class=\\\"left carousel-control carousel-control-prev\\\"\\n     *ngIf=\\\"slides.length > 1\\\"\\n     [class.disabled]=\\\"checkDisabledClass('prev')\\\"\\n     [attr.data-bs-target]=\\\"'#'+currentId\\\"\\n     (click)=\\\"previousSlide()\\\"\\n      tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-prev carousel-control-prev-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span *ngIf=\\\"isBs4\\\" class=\\\"sr-only visually-hidden\\\">Previous</span>\\n  </a>\\n  <a class=\\\"right carousel-control carousel-control-next\\\"\\n     *ngIf=\\\"slides.length > 1\\\"\\n     [class.disabled]=\\\"checkDisabledClass('next')\\\"\\n     [attr.data-bs-target]=\\\"'#'+currentId\\\"\\n     (click)=\\\"nextSlide()\\\"\\n     tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-next carousel-control-next-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span class=\\\"sr-only visually-hidden\\\">Next</span>\\n  </a>\\n</div>\\n\", directives: [{ type: i2.NgIf, selector: \"[ngIf]\", inputs: [\"ngIf\", \"ngIfThen\", \"ngIfElse\"] }, { type: i2.NgForOf, selector: \"[ngFor][ngForOf]\", inputs: [\"ngForOf\", \"ngForTrackBy\", \"ngForTemplate\"] }, { type: i2.NgStyle, selector: \"[ngStyle]\", inputs: [\"ngStyle\"] }] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: CarouselComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'carousel', template: \"<div (mouseenter)=\\\"pause()\\\"\\n     (mouseleave)=\\\"onMouseLeave()\\\"\\n     (mouseup)=\\\"onMouseUp()\\\"\\n     (keydown)=\\\"keydownPress($event)\\\"\\n     (focusin)=\\\"pauseFocusIn()\\\"\\n     (focusout)=\\\"pauseFocusOut()\\\"\\n     [id]=\\\"currentId\\\"\\n     class=\\\"carousel slide\\\" tabindex=\\\"0\\\">\\n  <ng-container *ngIf=\\\"!_bsVer.isBs5 && showIndicators && slides.length > 1\\\">\\n    <ol class=\\\"carousel-indicators\\\">\\n      <li *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n          [class.active]=\\\"slide.active === true\\\"\\n          (click)=\\\"selectSlide(i)\\\">\\n      </li>\\n    </ol>\\n  </ng-container>\\n  <ng-container *ngIf=\\\"_bsVer.isBs5 && showIndicators && slides.length > 1\\\">\\n    <div class=\\\"carousel-indicators\\\">\\n      <button\\n        *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n        [class.active]=\\\"slide.active === true\\\"\\n        (click)=\\\"selectSlide(i)\\\"\\n        type=\\\"button\\\"\\n        [attr.data-bs-target]=\\\"'#'+currentId\\\"\\n        [attr.data-bs-slide-to]=\\\"i\\\" aria-current=\\\"true\\\"\\n      >\\n      </button>\\n    </div>\\n  </ng-container>\\n  <div class=\\\"carousel-inner\\\" [ngStyle]=\\\"{'display': multilist ? 'flex' : 'block'}\\\">\\n    <ng-content></ng-content>\\n  </div>\\n  <a class=\\\"left carousel-control carousel-control-prev\\\"\\n     *ngIf=\\\"slides.length > 1\\\"\\n     [class.disabled]=\\\"checkDisabledClass('prev')\\\"\\n     [attr.data-bs-target]=\\\"'#'+currentId\\\"\\n     (click)=\\\"previousSlide()\\\"\\n      tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-prev carousel-control-prev-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span *ngIf=\\\"isBs4\\\" class=\\\"sr-only visually-hidden\\\">Previous</span>\\n  </a>\\n  <a class=\\\"right carousel-control carousel-control-next\\\"\\n     *ngIf=\\\"slides.length > 1\\\"\\n     [class.disabled]=\\\"checkDisabledClass('next')\\\"\\n     [attr.data-bs-target]=\\\"'#'+currentId\\\"\\n     (click)=\\\"nextSlide()\\\"\\n     tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-next carousel-control-next-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span class=\\\"sr-only visually-hidden\\\">Next</span>\\n  </a>\\n</div>\\n\" }]\n        }], ctorParameters: function () { return [{ type: CarouselConfig }, { type: i0.NgZone }]; }, propDecorators: { noWrap: [{\n                type: Input\n            }], noPause: [{\n                type: Input\n            }], showIndicators: [{\n                type: Input\n            }], pauseOnFocus: [{\n                type: Input\n            }], indicatorsByChunk: [{\n                type: Input\n            }], itemsPerSlide: [{\n                type: Input\n            }], singleSlideOffset: [{\n                type: Input\n            }], isAnimated: [{\n                type: Input\n            }], activeSlideChange: [{\n                type: Output\n            }], slideRangeChange: [{\n                type: Output\n            }], activeSlide: [{\n                type: Input\n            }], startFromIndex: [{\n                type: Input\n            }], interval: [{\n                type: Input\n            }] } });\n\nclass SlideComponent {\n    constructor(carousel) {\n        /** Is current slide active */\n        this.active = false;\n        this.itemWidth = '100%';\n        this.order = 0;\n        this.isAnimated = false;\n        /** Wraps element by appropriate CSS classes */\n        this.addClass = true;\n        this.multilist = false;\n        this.carousel = carousel;\n    }\n    /** Fires changes in container collection after adding a new slide instance */\n    ngOnInit() {\n        var _a;\n        this.carousel.addSlide(this);\n        this.itemWidth = `${100 / this.carousel.itemsPerSlide}%`;\n        this.multilist = ((_a = this.carousel) === null || _a === void 0 ? void 0 : _a.itemsPerSlide) > 1;\n    }\n    /** Fires changes in container collection after removing of this slide instance */\n    ngOnDestroy() {\n        this.carousel.removeSlide(this);\n    }\n}\nSlideComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: SlideComponent, deps: [{ token: CarouselComponent }], target: i0.ɵɵFactoryTarget.Component });\nSlideComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.1.1\", type: SlideComponent, selector: \"slide\", inputs: { active: \"active\" }, host: { properties: { \"attr.aria-hidden\": \"!active\", \"class.multilist-margin\": \"multilist\", \"class.active\": \"this.active\", \"style.width\": \"this.itemWidth\", \"style.order\": \"this.order\", \"class.carousel-animation\": \"this.isAnimated\", \"class.item\": \"this.addClass\", \"class.carousel-item\": \"this.addClass\" } }, ngImport: i0, template: `\n    <div [class.active]=\"active\" class=\"item\">\n      <ng-content></ng-content>\n    </div>\n  `, isInline: true, styles: [\":host.carousel-animation{transition:opacity .6s ease,visibility .6s ease;float:left}:host.carousel-animation.active{opacity:1;visibility:visible}:host.carousel-animation:not(.active){display:block;position:absolute;opacity:0;visibility:hidden}:host.multilist-margin{margin-right:auto}:host.carousel-item{perspective:1000px}\\n\"] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: SlideComponent, decorators: [{\n            type: Component,\n            args: [{\n                    selector: 'slide',\n                    template: `\n    <div [class.active]=\"active\" class=\"item\">\n      <ng-content></ng-content>\n    </div>\n  `,\n                    // eslint-disable-next-line @angular-eslint/no-host-metadata-property\n                    host: {\n                        '[attr.aria-hidden]': '!active',\n                        '[class.multilist-margin]': 'multilist'\n                    },\n                    styles: [`\n    :host.carousel-animation {\n       transition: opacity 0.6s ease, visibility 0.6s ease;\n       float: left;\n    }\n    :host.carousel-animation.active {\n      opacity: 1;\n      visibility: visible;\n    }\n    :host.carousel-animation:not(.active) {\n      display: block;\n      position: absolute;\n      opacity: 0;\n      visibility: hidden;\n    }\n    :host.multilist-margin {\n      margin-right: auto;\n    }\n    :host.carousel-item {\n      perspective: 1000px;\n    }\n  `]\n                }]\n        }], ctorParameters: function () { return [{ type: CarouselComponent }]; }, propDecorators: { active: [{\n                type: HostBinding,\n                args: ['class.active']\n            }, {\n                type: Input\n            }], itemWidth: [{\n                type: HostBinding,\n                args: ['style.width']\n            }], order: [{\n                type: HostBinding,\n                args: ['style.order']\n            }], isAnimated: [{\n                type: HostBinding,\n                args: ['class.carousel-animation']\n            }], addClass: [{\n                type: HostBinding,\n                args: ['class.item']\n            }, {\n                type: HostBinding,\n                args: ['class.carousel-item']\n            }] } });\n\nclass CarouselModule {\n    static forRoot() {\n        return { ngModule: CarouselModule, providers: [] };\n    }\n}\nCarouselModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: CarouselModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nCarouselModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: CarouselModule, declarations: [SlideComponent, CarouselComponent], imports: [CommonModule], exports: [SlideComponent, CarouselComponent] });\nCarouselModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: CarouselModule, imports: [[CommonModule]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: CarouselModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [CommonModule],\n                    declarations: [SlideComponent, CarouselComponent],\n                    exports: [SlideComponent, CarouselComponent]\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CarouselComponent, CarouselConfig, CarouselModule, SlideComponent };\n"]},"metadata":{},"sourceType":"module"}